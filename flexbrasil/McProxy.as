package flexbrasil{	import flash.events.*;	import flash.utils.*;	import flash.display.*	import flexbrasil.Calc	public class McProxy extends Proxy	{		private var mc:*		public function McProxy(mc)		{			this.mc = mc		}				public function set init(callback:Function):void		{			if (mc.parent == null)			{				var addedToStage = function(e){					callback()					mc.removeEventListener(Event.ADDED_TO_STAGE, addedToStage)				}				mc.addEventListener(Event.ADDED_TO_STAGE, addedToStage)			}else{				callback()			}		}		/**		 * contrário de isLivePreview		 */		public function get isRuntime()		{			return ! isLivePreview		}		/**		 * @return boolean true se o MovieClip estiver dentro do flash.		 */		public function get isLivePreview()		{			return mc.parent != null && 				   getQualifiedClassName(mc.parent) == "fl.livepreview::LivePreviewParent";		}		/**		 * Varre o movieClip, adicionando os listeners baseado no nome dos seus métodos.		 * Por exemplo, se a classe tiver um metodo chamado onEnterFrame,		 * ele será adicionado como o listener do evento enterFrame		 * @param match:RegExp expressao regular utilizada para filtrar os metodos 		 * que serão adicionados automaticamente como eventos handlers.		 * on_addedToStage e onAddedToStage são convertido para o evento addedToStage		 * @TODO, se nao tiver parametro, faz um wrapper.		 */		public function autoEvents(match = "^on[A-Z_].+")		{			var rx:RegExp = new RegExp(match)			for each(var method in describeType(mc).method.@name)			{				if (rx.test(method))				{					// remove o prefixo					var eventName = method.toString().replace(/^on_?/, "")					// converte a primeira letra para minúsculo					eventName = eventName.substr(0, 1).toLowerCase() + eventName.substr(1)					// adiciona o evento					this[eventName] = this.mc[method]				}			}		}		/**		 * Desloca o objeto nas cordenadas x,y baseado em sua rotação		 */		public function set mover(pixels:Number):void		{			var dx = Math.cos(Calc.radianos(mc.rotation))			var dy = Math.sin(Calc.radianos(mc.rotation))			mc.x += dx * pixels			mc.y += dy * pixels		}		override flash_proxy function callProperty(methodName:*, ... args):*		{			mc.addEventListener(methodName, args[0])		}				/**		 * @TODO: encontrar uma utilidade		 */		override flash_proxy function getProperty(name:*):* {		}		override flash_proxy function setProperty(name:*, value:*):void		{			mc.addEventListener(name, value)		}		/**		 * gotoAndStop para o proximo label.		 * @TODO: talvez criar uma propriedade que retorna apenas o nome do proximo label		 * se loop for true, volta para o primeiro label se estiver no fim.		 */		public function nextLabel(loop = false)		{			var next = false			for each(var i in mc.currentLabels)			{				if (next)				{					mc.gotoAndStop(i.name)					return				}				if (i.name == mc.currentLabel)					next = true			}			if (loop)				mc.gotoAndStop(mc.currentLabels[0].name)		}		/**		 * gotoAndStop para o label anterior.		 * @TODO: talvez criar uma propriedade que retorna apenas o nome do label anterior 		 * se loop for true, volta para o último label se estiver no primeiro.		 */		public function prevLabel(loop = false)		{			var next = false			var labels = mc.currentLabels.reverse()			for each(var i in labels)			{				if (next)				{					mc.gotoAndStop(i.name)					return				}				if (i.name == mc.currentLabel)					next = true			}			if (loop)				mc.gotoAndStop(labels[0].name)		}		/**		 * retorna o path completo do MovieClip, separado por "." (ponto)		 * Decidir se retorna stage e root no path também.		 */		public function get path():String		{			if (mc.parent == mc.root) return mc.name // nao traz stage.root			if (mc.parent == null && mc is Stage) return "stage"			if (mc == mc.root) return $(mc.parent).path + "." + "root"			return $(mc.parent).path + "." + mc.name		}		/**		 * Iterage nos filhos do container, retornando um array com todos eles.		 * Retorna um array vazio para qualquer outra classe.		 */		public function get children():Array		{			if ( ! (mc is DisplayObjectContainer) ) return []			var a:Array = []			for (var i = 0; i < mc.numChildren; i++)				a.push(mc.getChildAt(i));			return a		}		public function recursiveChildren(callback:Function):void		{			if ( ! (mc is DisplayObjectContainer) ) return			try {				for (var i = 0; i < mc.numChildren; i++)				{					var child:DisplayObject = mc.getChildAt(i)					callback(child)					$(child).recursiveChildren(callback)				}			} catch(e:Break) {				return			}		}	}}